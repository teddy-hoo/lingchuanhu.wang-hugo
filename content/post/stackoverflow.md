---
title: "缓冲区溢出"
date: 2018-04-01T13:02:05+08:00
draft: false
tags: ["基础知识"]
categories: ["操作系统"]
---
# 缓冲区溢出

C语言对于数组引用不进行任何边界检查，而且局部变量和状态信息都存放在栈中，所以对越界的数组元素的写操作会破坏存储在栈中的状态信息。

一个栈帧的图示：

```

------------------
*
*
*
========
较早的帧
------------------
调用参数n
...
调用参数1
返回地址
========
调用者的帧
------------------
帧起始地址
...
被保存的寄存器
本地变量
临时变量
参数构造区域
========
当前帧
------------------

```
当程序使用这个被破坏的状态，试图重新加载寄存器或执行ret指令是，就会出现不可预知的后果。

### 缓冲区溢出（buffer overflow）
在栈中分配某个字节数组来保存一个字符串，但是字符创的长度超出了为数组分配的空间。下面的代码：

```
char *gets(char *s)
{
	int c;
	char *dest = s;
	int gotchar = 0;
	while((c = getchar()) != '\n' && c != EOF) {
		*dest++ = c;
		gotchar = 1;
	}
	*dest++ = '\0';
	if (c == EOF && !gotchar))
		return NULL;
	return s;
}

void echo()
{
	char buf[8];
	gets(buf);
	puts(buf);
}
```
上述代码的栈结构如下：

```
----------------------------
...
返回地址
==================
调用者的栈
----------------------------
保存的%ebp
保存的%ebx
buf数组
[7] [6] [5] [4] [3] [2] [1]
----------------------------
............................
----------------------------
```
值得注意的是，栈的增长方向是地址递减，而数组的遍历方便是相反的。

所以当buf数组写超过了8个Byte的时候，就会破坏栈中的数据。


## 对抗缓冲区溢出攻击

#### 栈随机化
即每次分配栈空间的时候，随机多分配出一块内容，使得调用栈之间的距离不是固定值。

#### 栈破坏监测
在缓冲区与栈之间插入一个金丝雀值（canary），在函数返回之前，检查这个金丝雀值。

#### 限制可执行代码区域
允许存储器有三种访问形式：读、写、执行。
